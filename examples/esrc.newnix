#!/usr/bin/env es
# vim: ft=nxes
## Simple es configuration script
LANG=(en_US.UTF-8)
TERM=(xterm-256color)
path=(/sbin /bin /usr/sbin /usr/bin /usr/local/sbin /usr/local/bin $home^/bin $home^/bin/c)
editors = (nvim kak vim vis ed)

## TODO Improve comments
## Check for nvim and set it as the editor of choice
fn geteditor {
	for (e = $editors) {
		catch @ {
			## Exception handler, no else clause needed
			{if {eq $1 return} # 'return' is implemented as an exception, so we need to check the exception type
				{$1 $2}}
		} {
			{%seq
				{%pathsearch $e}
				{return $e} ## Return the editor we found
			}
		}
	}
}

## Simple function to print the result of its arguments
## this reduces the need of typing `echo <={...}` during interactive use
fn print {
	echo <={$*}
}

## Settor function to automatically set EDITOR and VISUAL
## to whatever the value of $editor is
set-editor = @ {
	{local (set-EDITOR=) EDITOR = $*}
	{local (set-VISUAL=) VISUAL = $*}
	{result $*}
}

## Replace character in string
fn replace original replacement separator { 
	return <= {%flatten $replacement <= {
		%split $separator $original
	}}
}

## Utility function to get current TTY in a history-friendly manner
fn histtty { 
	local (ht= <={%split \n <={%backquote / tty}})
		{return <= {%flatten / $ht(2) $ht(3)}}
}

## Settor function to create a per-session history file
set-TTY = @ {
	{local (set-history=) history = $home^/.history.^<={replace $* . /}}
	{local (set-GPG_TTY=) GPG_TTY = $*}
	{result $*}
}

## Make reloading the config easier
fn reload {
	. $home^/.esrc
}

## Everything is vim
fn vim {
	$editor $*
}

## Create a '++' pseudo-operator, mutates state internally
## Unfortunately due to the ubiquity of getopt(3) style argument parsing
## adding a corresponding '--' pseudo-operator is not practical.
fn ++ i {
	## The argument 'i' is meant to be a variable reference,
	## used like so:
	## ; x = 0
	## ; ++ x
	## ; echo $x
	## 1
	$i = <= {
		$&sum $$i 1
	}
}

## Creates simple equality checks, similar to '==' in C
## or the '='/'eq?' forms in some lisp dialects
fn eq a b {
	~ $a $b
}

## Modified form to accept variable references instead of values
fn veq a b {
	~ $$a $$b
}

## Enable prettier printing of the current primitives
fn primitives {
	local (pi = 1)
	let (plist = <= {$&primitives}) {
		echo Found $#plist primitives:
		for (p = $plist) {
			echo $pi: $p
			++ pi
		}
	}
}

## Automatically set editor related variables
editor =<={geteditor}
TTY =/dev/^<={histtty}
